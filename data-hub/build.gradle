plugins {
    id 'java'
    id 'eclipse'
    id 'idea'
    id 'net.saliman.properties' version '1.4.5'
	id 'com.marklogic.ml-gradle' version '2.3.1'
	id 'com.marklogic.ml-data-hub' version '1.0.0-rc.1'
}

repositories {
    mavenLocal()
    jcenter()
    maven {url 'http://developer.marklogic.com/maven2/'}
    // From slush.  is this needed?
    maven {url "http://repository.cloudera.com/artifactory/cloudera-repos/" }
}

// Add MLCP for custom task to load dictionaries
configurations {
    mlcp
}

dependencies {
    compile 'com.marklogic:marklogic-data-hub:+'
    compile 'com.marklogic:marklogic-xcc:8.0.5'
    
    // Needed for loading modules into MarkLogic
    compile "com.marklogic:ml-javaclient-util:2.9.0-RC1"
    
    // MLCP dependancies
    mlcp "com.marklogic:mlcp:8.0-5"
    /**
	 * If you need to import delimited text, be sure to include this dependency as well.
	 */
	mlcp "org.apache.commons:commons-csv:1.2"
	/**
	 * mlcp uses Log4j for logging, and if Log4j can't find a configuration file, it will complain and you'll
	 * get none of mlcp's usually-useful logging. It is recommended then that your Gradle configuration for
	 * mlcp include a directory or some other resource that provides a log4j.properties file.
	 */
	  mlcp files("lib")
}

// Map values from gradle.properties to tokens in config documents
ext {
    // mlAppConfig is an instance of com.marklogic.appdeployer.AppConfig
    mlAppConfig {
        // override some default values with our values
        modulesDatabaseName = mlModulesDbName
        triggersDatabaseName = mlTriggersDbName
        schemasDatabaseName = mlSchemasDbName
        restPort = Integer.parseInt(mlStagingPort)

        // Configure custom tokens for our json files
        customTokens.put("%%STAGING_SERVER_NAME%%", mlStagingAppserverName)
        customTokens.put("%%STAGING_SERVER_PORT%%", mlStagingPort)
        customTokens.put("%%STAGING_DB_NAME%%", mlStagingDbName)

        customTokens.put("%%FINAL_SERVER_NAME%%", mlFinalAppserverName)
        customTokens.put("%%FINAL_SERVER_PORT%%", mlFinalPort)
        customTokens.put("%%mlFinalDbName%%", mlFinalDbName)

        customTokens.put("%%TRACE_SERVER_NAME%%", mlTraceAppserverName)
        customTokens.put("%%TRACE_SERVER_PORT%%", mlTracePort)
        customTokens.put("%%TRACE_DB_NAME%%", mlTraceDbName)
		
        customTokens.put("%%mlOdbcAppserverName%%", mlOdbcAppserverName)
        customTokens.put("%%mlOdbcPort%%", mlOdbcPort)    		

        modulePaths = ["plugins"]
    }
}

ext {
    myForestNamesAndReplicasCounts = [ "Security": 1, "Schemas": 1, "Meters": 1, "App-Services": 1]
}

// Override the default database for deploying views
ext {
    mlAppDeployer.getCommand("DeployViewSchemasCommand").databaseIdOrName = mlFinalDbName
}

/*
 * The mlConfigureForestReplicas task exposes an instance of ConfigureForestReplicasCommand as the "command" attribute.
 * This allows us to easily modify the forestNamesAndReplicaCounts map, where each key is the name of a primary forest,
 * and the value of each key is the number of replicas to create on each host in the cluster (except the host that the
 * primary forest resides on).
 *
 * Note that this is usually most useful for supporting failover for MarkLogic apps such as Admin and App-Services. For
 * failover for your own forests, you can use this approach, but you may also wish to create forest config files under
 * src/main/ml-config/forests.
 */
mlConfigureForestReplicas.command.forestNamesAndReplicaCounts = myForestNamesAndReplicasCounts

/*
 * mlDeleteForestReplicas can then use the same map as mlConfigureForestReplicas, as it will delete replicas for all of
 * the forests identified by the keys in the map. This task could be called before mlUndeploy, for example, to first
 * delete all of the forest replicas, thus allowing the primary forests to be deleted safely.
 */
mlDeleteForestReplicas.command.forestNamesAndReplicaCounts = myForestNamesAndReplicasCounts

task importDictionaries(type: com.marklogic.gradle.task.MlcpTask) {
	classpath = configurations.mlcp
	command = "IMPORT"
	database = mlFinalDbName
	input_file_path = "data/dictionaries"
	output_collections = "dictionaries"
	output_permissions = "rest-reader,read,rest-writer,update"
	output_uri_replace = ".*/data,''"
}

task importSKOSReference(type: com.marklogic.gradle.task.MlcpTask) {
	classpath = configurations.mlcp
	command = "IMPORT"
	database = mlFinalDbName
	input_file_path = "data/SKOS"
	input_file_type = "RDF"
	output_collections = "SKOS,ABAWD,http://www.dhr.state.md.us/conceptschemes"
	output_permissions = "rest-reader,read,rest-writer,update"
	output_uri_replace = ".*/data,''"
}